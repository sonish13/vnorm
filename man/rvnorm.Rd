% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rvnorm.R
\name{rvnorm}
\alias{rvnorm}
\title{The Variety Normal Distribution}
\usage{
rvnorm(
  n,
  poly,
  sd,
  output = "simple",
  chains = 4L,
  warmup = max(500, floor(n/2)),
  inc_warmup = FALSE,
  thin = 1L,
  inject_direct = FALSE,
  verbose = FALSE,
  cores = min(chains, getOption("mc.cores", 1L)),
  homo = TRUE,
  normalized = homo,
  w,
  vars,
  numerator,
  denominator,
  refresh = 0L,
  code_only = FALSE,
  pre_compiled = TRUE,
  user_compiled = FALSE,
  ...
)
}
\arguments{
\item{n}{The number of draws desired from each chain after warmup.}

\item{poly}{An mpoly object.}

\item{sd}{The "standard deviation" component of the normal kernel.}

\item{output}{\code{"simple"}, \code{"tibble"}, \code{"stanfit"}.}

\item{chains}{The number of chains to run for the random number generation,
see \code{\link[=stan]{stan()}}.}

\item{warmup}{Number of warmup iterations in \code{\link[=stan]{stan()}}.}

\item{inc_warmup}{If \code{TRUE}, the MCMC warmup steps are included in the
output.}

\item{thin}{\code{\link[=stan]{stan()}} \code{thin} parameter.}

\item{inject_direct}{Directly specify printed polynomial to string inject
into the stan code. Requires you specify \code{vars}, \code{numerator}, and
\code{denominator}.}

\item{verbose}{\code{TRUE} or \code{FALSE}; determines level of messaging.}

\item{cores}{The number of CPU cores to distribute the chains across, see
\code{\link[=stan]{stan()}}.}

\item{homo}{If \code{TRUE}, the sampling is done from homoskedastic variety
normal distribution.}

\item{normalized}{If \code{TRUE}, the polynomial is gradient-normalized. This
is highly recommended. Set to \code{TRUE} if homo = \code{TRUE}}

\item{w}{A named list of box constraints for vectors to be passed to Stan,
see examples. A If a single number, a box window (-w,w) is applied to all
variables.}

\item{vars}{A character vector of the indeterminates in the distribution.}

\item{numerator, denominator}{A character(1) containing the printed numerator
of the variety normal distribution.}

\item{refresh}{The \code{refresh} argument of \code{\link[=stan]{stan()}}, which governs how
much information is provided to the user while sampling.}

\item{code_only}{If \code{TRUE}, will only formulate and return Stan code.}

\item{pre_compiled}{Whether to use pre-compiled stan models or not. Available
for polynomials with three indeterminates and three degrees. Defaults to
\code{TRUE}.}

\item{user_compiled}{If\code{TRUE}, user compiled stan program made using
\link{compile_stan_code} is used. Defaults to \code{FALSE}}

\item{...}{Additional parameters to pass to \code{\link[=stan]{stan()}}.}
}
\value{
Either (1) matrix whose rows are the individual draws from the
distribution, (2) a \linkS4class{tbl_df} object with the draws along with
additional information, or (3) an object of class \linkS4class{stanfit}.
}
\description{
Un-normalized density function and random generation for the variety normal
distribution with mean equal to \code{poly} and "standard deviation" equal to
\code{sd}. Please see details for caveats.
}
\details{
If the variety you are interested in is connected, this strategy should work
well out of the box.  If it isn't, you'll likely need to rely on running
multiple chains, and it is very likely, if not probable, that the sampling
will be biased to one or more of those components and down-sample others.
Question: what is the relative likelihood of each component, or an equal unit
of length, on different components? How does this generalize to more
varieties of varying dimensions?
}
\examples{
# Example code provided in documentation

}
