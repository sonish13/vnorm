% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/project_onto_variety.R
\name{project-onto-variety}
\alias{project-onto-variety}
\alias{project_onto_variety}
\alias{project_onto_variety_lagrange}
\alias{project_onto_variety_gradient_descent}
\alias{project_onto_variety_newton}
\title{Projection onto a Variety}
\usage{
project_onto_variety(
  x0,
  poly,
  dt = 0.01,
  varorder = sort(mpoly::vars(poly)),
  n_correct = 2,
  al = rnorm(2),
  message = FALSE,
  tol = .Machine$double.eps^(1/2),
  gfunc,
  dgfunc,
  ddgfunc,
  bias = 0,
  adaptive = TRUE,
  dt_min = 1e-06,
  dt_max = 0.1,
  error_tol = 0.01
)

project_onto_variety_lagrange(
  x0,
  poly,
  varorder = mpoly::vars(poly),
  method = "newton",
  maxit = 1000,
  tol = .Machine$double.eps^(1/2),
  tol_x = .Machine$double.eps^(1/2),
  message = FALSE,
  ...
)

project_onto_variety_gradient_descent(
  x0,
  poly,
  varorder = mpoly::vars(poly),
  ga = 0.01,
  max_ga = 0.1,
  method = c("line", "optimal", "fixed"),
  tol = .Machine$double.eps^(1/2),
  tol_x = .Machine$double.eps^(1/2),
  maxit = 1000,
  message = FALSE
)

project_onto_variety_newton(
  x0,
  poly,
  varorder = mpoly::vars(poly),
  ga = 1e-04,
  max_ga = 2,
  method = c("line", "fixed"),
  tol = .Machine$double.eps^(1/2),
  tol_x = .Machine$double.eps^(1/2),
  maxit = 1000,
  message = FALSE
)
}
\arguments{
\item{x0}{A numeric vector giving one point to be projected, or a numeric
matrix/data frame whose rows are points to be projected.}

\item{poly}{An \code{mpoly} object, typically created with \code{\link[mpoly:mp]{mpoly::mp()}}.}

\item{dt}{The t-mesh size for the homotopy.}

\item{varorder}{A character vector specifying the variable order to pass to
\code{\link[mpoly:as-function]{mpoly::as.function.mpoly()}}.}

\item{n_correct}{The number of Newton correction iterations to use.}

\item{al}{A numeric vector of length 2; the patch to do projective
calculations over.}

\item{message}{If \code{TRUE}, the user is issued messages on the algorithm's
progress.}

\item{tol}{A tolerance on the residual; a warning is issued if the magnitude
of the residual is larger than \code{tol}.}

\item{gfunc, dgfunc, ddgfunc}{The polynomial \link{poly}, its gradient, and its
Hessian as functions. Only used in \code{\link[=project_onto_variety]{project_onto_variety()}}, and computed
internally if not provided.}

\item{bias}{A multiple to add to the identity to make the Jacobian
invertible.}

\item{adaptive}{Defaults to \code{TRUE}. Whether to use adaptive step sizes.}

\item{dt_min, dt_max}{Minimum and maximum allowed step sizes during adaptive
integration (default: \code{1e-6} and \code{0.1}).}

\item{error_tol}{Tolerance used for adaptive step size control
(default: \code{0.01}). Smaller values give more accurate results at the cost of
runtime.}

\item{method}{Used in \code{\link[=project_onto_variety_lagrange]{project_onto_variety_lagrange()}},
\code{\link[=project_onto_variety_gradient_descent]{project_onto_variety_gradient_descent()}}, and
\code{\link[=project_onto_variety_newton]{project_onto_variety_newton()}}. In the Lagrange method, if
\code{"newton"}, a simple R implementation of Newton's method to solve the
nonlinear algebraic system generated by the Lagrangian; otherwise, a
character string to pass to \code{\link[stats:optim]{stats::optim()}} to minimize
the sum of the squares of the Lagrangian. In the gradient-descent and
Newton methods, \code{method} controls the line-search/fixed-step update:
\code{"line"} (line search), \code{"optimal"}, or \code{"fixed"}.}

\item{maxit}{Number of maximum iterations in solving Newton's method.}

\item{tol_x}{A tolerance on subsequent step sizes.}

\item{...}{Additional arguments to pass to \code{\link[stats:optim]{stats::optim()}} when \code{method} is
not \code{"newton"}.}

\item{ga}{Learning rate for gradient descent.}

\item{max_ga}{Maximum learning rate for gradient descent line search.}
}
\value{
If \code{x0} is a vector, a numeric vector the same length as \code{x0}. If
\code{x0} is a matrix/data frame, a matrix/data frame of projected points with
the same number of rows.
}
\description{
An R-based implementation of gradient-descent homotopies with adaptive step
sizes for Euler prediction. The Lagrange version uses Newton's method on the
Lagrangian system.
}
\examples{

library("ggplot2")
library("mpoly")

\dontrun{
## basic usage
x0 <- c(1, 1)
p1 <- mp("x^2 + y^2 - 1")
x1_proj <- project_onto_variety(x0, p1)
x1_proj

# Residual on the variety should be near zero
as.function(p1)(x1_proj)

df1 <- data.frame(
  x = x0[1], y = x0[2],
  x_proj = x1_proj[1], y_proj = x1_proj[2]
)
ggplot() +
  geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2)) +
  geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df1) +
  coord_equal()

## adaptive time stepping (default) versus fixed step size
x2_adapt <- project_onto_variety(x0, p1)
x2_fixed <- project_onto_variety(x0, p1, adaptive = FALSE, dt = 0.01)
x2_strict <- project_onto_variety(x0, p1, error_tol = 0.001)

rbind(
  adaptive = x2_adapt,
  fixed = x2_fixed,
  adaptive_strict = x2_strict
)

# Optional: inspect adaptive step messages
project_onto_variety(x0, p1, message = TRUE)

## precomputing polynomial/gradient/Hessian functions
varorder <- c("x", "y")
gfunc <- as.function(p1, varorder = varorder)
dg <- stats::deriv(p1, var = varorder)
dgfunc <- as.function(dg, varorder = varorder)
ddg <- lapply(dg, stats::deriv, var = varorder)
ddgfunc_list <- lapply(ddg, as.function, varorder = varorder, silent = TRUE)
ddgfunc <- function(x) sapply(ddgfunc_list, function(f) f(x))
project_onto_variety(x0, p1, gfunc = gfunc, dgfunc = dgfunc, ddgfunc = ddgfunc)

## projecting multiple points (matrix or data frame input)
x2 <- rbind(c(1, 1), c(-1, 0.3), c(0.2, -1.3))
project_onto_variety(x2, p1)
project_onto_variety(as.data.frame(x2), p1)

## alternative projection methods
project_onto_variety_lagrange(x0, p1)
project_onto_variety_newton(x0, p1)
project_onto_variety_gradient_descent(x0, p1, method = "line")
project_onto_variety_gradient_descent(x0, p1, method = "optimal")
project_onto_variety_gradient_descent(x0, p1, method = "fixed")

## naive usages / method comparison on a small grid
# (gradient descent methods minimize g(x)^2 directly)
library("dplyr")
set.seed(1)
grid <- expand.grid(x = seq(-1, 1, by = 0.5), y = seq(-1, 1, by = 0.5))
grid$x <- jitter(grid$x)
grid$y <- jitter(grid$y)

proj_homotopy <- project_onto_variety(grid, p1)
proj_gd_opt <- project_onto_variety_gradient_descent(grid, p1, method = "optimal")
proj_newton <- project_onto_variety_newton(grid, p1)

names(proj_homotopy) <- c("x_proj", "y_proj")
names(proj_gd_opt) <- c("x_proj", "y_proj")
names(proj_newton) <- c("x_proj", "y_proj")

df_cmp <- bind_rows(
  bind_cols(grid, proj_homotopy) |> mutate(method = "homotopy (adaptive default)"),
  bind_cols(grid, proj_gd_opt)   |> mutate(method = "naive gd on g^2 (optimal)"),
  bind_cols(grid, proj_newton)   |> mutate(method = "newton on g^2")
)

ggplot() +
  geom_variety(poly = p1, xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2)) +
  geom_segment(
    aes(x, y, xend = x_proj, yend = y_proj),
    data = df_cmp, inherit.aes = FALSE, alpha = 0.6
  ) +
  geom_point(aes(x, y), data = grid, inherit.aes = FALSE, size = 0.8) +
  coord_equal() +
  facet_wrap(~ method)

## changing adaptive control parameters
project_onto_variety(
  x0, p1,
  adaptive = TRUE,
  dt = 0.05,
  dt_min = 1e-5,
  dt_max = 0.2,
  error_tol = 0.005,
  message = TRUE
)

## more complex curve
p_complex <- mp("(x^2 + y^2)^2 - 2 * (x^2 - y^2)")
x_complex <- c(1, 1)
x_complex_proj <- project_onto_variety(x_complex, p_complex)
df_complex <- data.frame(
  x = x_complex[1], y = x_complex[2],
  x_proj = x_complex_proj[1], y_proj = x_complex_proj[2]
)
ggplot() +
  geom_variety(poly = p_complex, xlim = c(-2, 2), ylim = c(-2, 2)) +
  geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df_complex) +
  coord_equal()

## projecting a sample from rvnorm (batch usage)
# cut down on draws for example runtime
samps <- rvnorm(500, p1, sd = 0.05, output = "tibble")
idx <- sample(seq_len(nrow(samps)), size = min(75, nrow(samps)))
subsamps <- samps[idx, , drop = FALSE]
proj_sub <- project_onto_variety(subsamps[, c("x", "y")], p1)
names(proj_sub) <- c("x_proj", "y_proj")
df_sub <- dplyr::bind_cols(subsamps, proj_sub)

ggplot(df_sub, aes(x, y)) +
  geom_segment(aes(xend = x_proj, yend = y_proj), alpha = 0.4) +
  geom_point(size = 0.8) +
  geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2), inherit.aes = FALSE) +
  coord_equal()

## higher-dimensional example
x3 <- c(1, 1, 1)
p2 <- mp("x^2 + y^2 + z^2 - 1")
project_onto_variety(x3, p2)
}
}
\references{
Griffin, Z. and J. Hauenstein (2015). Real solutions to systems
of polynomial equations and parameter continuation. \emph{Advances in
Geometry} 15(2), pp.173--187.

Bates, D., J. Hauenstein, A. Sommese, and C. Wampler (2013).
Numerically Solving Polynomial Systems with Bertini. SIAM. pp.34--35.
}
\author{
David Kahle
}
