
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "vnorm"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "vnorm-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('vnorm')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("compile_stan_code")
> ### * compile_stan_code
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compile_stan_code
> ### Title: Compile a Stan Model for User-Defined Polynomials
> ### Aliases: compile_stan_code
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D # compile a model that looks like b0 + bx6 x^6 + by6 y^6 for later input
> ##D p <- mp("x^6 + y^6 - 1") # template polynomial
> ##D samps <- rvnorm(1000, p, sd = .05)
> ##D head(samps)
> ##D compile_stan_code(p) # allows to change coefficients
> ##D p <- mp("x^6 + 8 y^6 - 1")
> ##D rvnorm(1e4, p, .05, user_compiled = TRUE)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compile_stan_code", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("geom_variety")
> ### * geom_variety
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geom_variety
> ### Title: One-Dimensional Varieties in Two Dimensions
> ### Aliases: geom_variety stat_variety StatVariety GeomVariety
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> library("ggplot2")
> 
> # 1) Ellipse
> p1 <- mp("x^2 + 4 y^2 - 1")
> ggplot() +
+   geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2)) +
+   coord_equal()
> 
> # 3) Folium of Descartes (loop with an asymptote) - variety with singularity
> p3 <- mp("x^3 + y^3 - 3 x y")
> ggplot() +
+   geom_variety(poly = p3, xlim = c(-2, 3), ylim = c(-2, 3)) +
+   coord_equal()
> 
> # 4) "Heart" curve (classic implicit heart)
> p4 <- mp("(x^2 + y^2 - 1)^3 - x^2 y^3")
> ggplot() +
+   geom_variety(poly = p4, xlim = c(-2, 2), ylim = c(-2, 2)) +
+   coord_equal() +
+   theme(legend.position = "top")
> 
> # 5) A 2-polynomial system (mpolyList): circle and xy = 0.25
> ps <- mp(c("x^2 + y^2 - 1", "x y - 0.25"))
> ggplot() +
+   geom_variety(poly = ps, xlim = c(-2, 2), ylim = c(-2, 2)) +
+   coord_equal()
> 
> # 5) Using shift for squared polynomials (same variety, no zero crossing on grid)
> library(mpoly)

Attaching package: ‘mpoly’

The following object is masked from ‘package:ggplot2’:

    vars

> p_shift <- mp("x^2 + y^2 - 1")^2
> ggplot() +
+   geom_variety(poly = p_shift, xlim = c(-2, 2), ylim = c(-2, 2)) +
+   coord_equal()
All values are positive on the plotting grid; try shift = -0.00101684.
Zero contours were generated
> 
> 
> 
> ## known issues
> ########################################
> 
> # 1) singularities Lemniscate of Bernoulli (figure-eight shaped)
> p <- mp("(x^2 + y^2)^2 - 2 x^2")
> ggplot() +
+   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2)) +
+   coord_equal()
> 
> # 2) non-zero crossing components
> p <- mp("x^2 + y^2 - 1")
> ggplot() +
+   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2)) +
+   coord_equal()
> 
> ggplot() +
+   geom_variety(poly = p^2, xlim = c(-2, 2), ylim = c(-2, 2), shift = -0.00101684) +
+   coord_equal()
Using shift = -0.00101684; duplicate contours merged.
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geom_variety", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:mpoly’, ‘package:ggplot2’

> nameEx("pdvnorm")
> ### * pdvnorm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pdvnorm
> ### Title: Pseudo-Density for the Variety Normal Distribution
> ### Aliases: pdvnorm
> 
> ### ** Examples
> 
> 
> library(mpoly)
> 
> ## Univariate usage
> p <- mp("x")
> pdvnorm(c(-1, 0, 1), p, sigma = 1)
[1] 0.2419707 0.3989423 0.2419707
> pdvnorm(0, p, sigma = 2, log = TRUE)
[1] -1.612086
> 
> ## Multivariate (square) system: two polynomials in two variables
> ps <- mp(c("x", "y"))
> X <- rbind(c(0, 0), c(1, 2), c(-1, 3))
> 
> ## Different sigma forms
> pdvnorm(X, ps, sigma = 1)
[1] 0.15915494 0.05167004 0.09653235
> pdvnorm(X, ps, sigma = c(1, 2))
[1] 0.11253954 0.06412310 0.08764588
> pdvnorm(X, ps, sigma = diag(c(1, 4)))
[1] 0.07957747 0.06006823 0.07022687
> 
> ## Multivariate (underdetermined): one polynomial in two variables
> p <- mp("x + y")
> X <- rbind(c(1, 1), c(2, -1), c(0, 3))
> pdvnorm(X, p, sigma = 1)
[1] 0.14676266 0.31069656 0.04204821
> 
> ## Multivariate (overdetermined): three polynomials in two variables
> p <- mp(c("x", "y", "x + y"))
> X <- rbind(c(1, 2), c(0, -1), c(2, 2))
> pdvnorm(X, p, sigma = diag(2),    homo = TRUE)
[1] 0.05854983 0.14241810 0.02689930
> pdvnorm(X, p, sigma = c(1, 2, 3), homo = FALSE)
[1] 0.0012905390 0.0170882873 0.0000896711
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pdvnorm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:mpoly’

> nameEx("project-onto-variety")
> ### * project-onto-variety
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: project-onto-variety
> ### Title: Projection onto a Variety
> ### Aliases: project-onto-variety project_onto_variety
> ###   project_onto_variety_lagrange project_onto_variety_gradient_descent
> ###   project_onto_variety_newton
> 
> ### ** Examples
> 
> 
> 
> library("ggplot2")
> 
> ## Not run: 
> ##D 
> ##D ## basic usage
> ##D ########################################
> ##D 
> ##D x0 <- c(1,1)
> ##D p <- mp("x^2 + y^2 - 1")
> ##D (x0_proj <- project_onto_variety(x0, p))
> ##D 
> ##D as.function(p)(x0_proj)
> ##D sqrt(2)/2
> ##D 
> ##D cbind(t(x0), t(x0_proj)) |>
> ##D   as.data.frame() |> tibble::as_tibble() |>
> ##D   purrr::set_names(c("x", "y", "x_proj", "y_proj")) -> df
> ##D 
> ##D ggplot() +
> ##D   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   geom_segment(
> ##D     aes(x, y, xend = x_proj, yend = y_proj),
> ##D     data = df) +
> ##D    theme(legend.position = "bottom")
> ##D 
> ##D # alternatives
> ##D 1 / sqrt(2)
> ##D project_onto_variety_lagrange(x0, p)
> ##D project_onto_variety_newton(x0, p)
> ##D project_onto_variety_gradient_descent(x0, p)
> ##D project_onto_variety_gradient_descent(x0, p, method = "line")
> ##D 
> ##D 
> ##D # number of variables > 2
> ##D x0 <- c(1,1,1)
> ##D p <- mp("x^2 + y^2 + z^2 - 1")
> ##D 1 / sqrt(3)
> ##D project_onto_variety(x0, p)
> ##D project_onto_variety_lagrange(x0, p)
> ##D project_onto_variety_newton(x0, p)
> ##D project_onto_variety_gradient_descent(x0, p)
> ##D project_onto_variety_gradient_descent(x0, p, method = "line")
> ##D 
> ##D 
> ##D ## options
> ##D ########################################
> ##D 
> ##D x0 <- c(1,1)
> ##D p <- mp("x^2 + y^2 - 1")
> ##D project_onto_variety(x0, p, message = TRUE)
> ##D project_onto_variety(x0, p, dt = .25, message = TRUE)
> ##D 
> ##D 
> ##D # precomputing the function, gradient, and hessian
> ##D varorder <- c("x", "y")
> ##D gfunc <- as.function(p, varorder = varorder)
> ##D 
> ##D dg <- stats::deriv(p, var = varorder)
> ##D dgfunc <- as.function(dg, varorder = varorder)
> ##D 
> ##D ddg <- lapply(dg, stats::deriv, var = varorder)
> ##D ddgfunc_list <- lapply(ddg, as.function, varorder = varorder, silent = TRUE)
> ##D ddgfunc <- function(x) sapply(ddgfunc_list, function(f) f(x))
> ##D 
> ##D project_onto_variety(x0, p, gfunc = gfunc, dgfunc = dgfunc, ddgfunc = ddgfunc)
> ##D 
> ##D ## adaptive time stepping examples
> ##D ########################################
> ##D 
> ##D x0 <- c(1, 1)
> ##D p <- mp("x^2 + y^2 - 1")
> ##D 
> ##D # Using adaptive time stepping (default)
> ##D x0_proj_adaptive <- project_onto_variety(x0, p, message = TRUE)
> ##D 
> ##D # For comparison, fixed step size (no adaptation)
> ##D x0_proj_fixed <- project_onto_variety(x0, p, adaptive = FALSE, dt = 0.01, message = TRUE)
> ##D 
> ##D # Using stricter error tolerance for adaptive stepping
> ##D x0_proj_strict <- project_onto_variety(x0, p, error_tol = 0.01, message = TRUE)
> ##D 
> ##D # Visualize
> ##D df_adaptive <- cbind(t(x0), t(x0_proj_adaptive)) |>
> ##D   as.data.frame() |> tibble::as_tibble() |>
> ##D   purrr::set_names(c("x", "y", "x_proj", "y_proj"))
> ##D 
> ##D ggplot() +
> ##D   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df_adaptive) +
> ##D   coord_equal() +
> ##D   theme(legend.position = "bottom")
> ##D 
> ##D 
> ##D ## changing adaptive control parameters
> ##D ########################################
> ##D 
> ##D x0_proj_custom_adaptive <- project_onto_variety(
> ##D   x0, p,
> ##D   adaptive = TRUE,
> ##D   dt = 0.05,
> ##D   dt_min = 1e-5,
> ##D   dt_max = 0.2,
> ##D   error_tol = 0.05,
> ##D   message = TRUE
> ##D )
> ##D 
> ##D 
> ##D ## larger systems
> ##D ########################################
> ##D 
> ##D x0 <- c(1,1,1)
> ##D p <- mp("x^2 + y^2 + z^2 - 1")
> ##D project_onto_variety(x0, p) # adaptive by default
> ##D project_onto_variety(x0, p, adaptive = FALSE, dt = 0.01) # fixed step size
> ##D 
> ##D ## more complex example
> ##D ########################################
> ##D 
> ##D x0 <- c(1,1)
> ##D p <- mp("(x^2 + y^2)^2 - 2 (x^2 - y^2)")
> ##D (x0_proj <- project_onto_variety(x0, p))
> ##D 
> ##D 
> ##D cbind(t(x0), t(x0_proj)) |>
> ##D   as.data.frame() |> tibble::as_tibble() |>
> ##D   purrr::set_names(c("x", "y", "x_proj", "y_proj")) -> df
> ##D p <- mp("(x^2 + y^2)^2 - 2 (x^2 - y^2)")
> ##D ggplot() +
> ##D   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   coord_equal() +
> ##D   geom_segment(
> ##D     aes(x, y, xend = x_proj, yend = y_proj),
> ##D     data = df, inherit.aes = FALSE
> ##D   ) +
> ##D    theme(legend.position = "bottom")
> ##D 
> ##D 
> ##D 
> ##D ## projecting a dataset - grid
> ##D ########################################
> ##D 
> ##D library("ggplot2")
> ##D library("dplyr")
> ##D 
> ##D (p <- mpoly::lissajous(5, 5, 0, 0))
> ##D # (p <- mpoly::lissajous(9, 9, 0, 0))
> ##D # p <- mp("x^2 + y^2 - 1")
> ##D ggplot() +
> ##D   geom_variety(poly = p, n = 251) +
> ##D  coord_equal() +
> ##D    theme(legend.position = "bottom")
> ##D set.seed(1)
> ##D (s <- seq(-1, 1, .25))
> ##D n <- length(s)
> ##D grid <- expand.grid(x = s, y = s)
> ##D grid$x <- jitter(grid$x)
> ##D grid$y <- jitter(grid$y)
> ##D 
> ##D ggplot(grid, aes(x, y)) + geom_point() + coord_equal()
> ##D 
> ##D grid_proj <- project_onto_variety(grid, p)
> ##D head(grid_proj)
> ##D names(grid_proj) <- c("x_proj", "y_proj")
> ##D 
> ##D ggplot() +
> ##D   geom_variety(poly = p, n = 501, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   coord_equal() +
> ##D   geom_segment(
> ##D     aes(x, y, xend = x_proj, yend = y_proj),
> ##D     data = bind_cols(grid, grid_proj), inherit.aes = FALSE
> ##D   ) +
> ##D   geom_point(aes(x, y), data = grid, inherit.aes = FALSE) +
> ##D    theme(legend.position = "bottom")
> ##D 
> ##D 
> ##D # here's what happens when you use a naive implementation -
> ##D # gradient descent on g^2 with line search
> ##D grid_proj_gd <- project_onto_variety_gradient_descent(grid, p, method = "optimal")
> ##D names(grid_proj_gd) <- c("x_proj", "y_proj")
> ##D 
> ##D grid_proj_lagrange <- project_onto_variety_lagrange(grid, p)
> ##D names(grid_proj_lagrange) <- c("x_proj", "y_proj")
> ##D 
> ##D grid_proj_newton <- project_onto_variety_newton(grid, p)
> ##D names(grid_proj_newton) <- c("x_proj", "y_proj")
> ##D 
> ##D df <- bind_rows(
> ##D   bind_cols(grid, grid_proj) |> mutate(method = "gradient descent homotopy"),
> ##D   bind_cols(grid, grid_proj_gd) |> mutate(method = "optimal gradient descent"),
> ##D   bind_cols(grid, grid_proj_newton) |> mutate(method = "newton"),
> ##D   bind_cols(grid, grid_proj_lagrange) |> mutate(method = "newton on lagrangian")
> ##D )
> ##D 
> ##D 
> ##D ggplot() +
> ##D   geom_variety(poly = p, n = 501, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   geom_segment(
> ##D     aes(x, y, xend = x_proj, yend = y_proj),
> ##D     data = df, inherit.aes = FALSE
> ##D   ) +
> ##D   geom_point(aes(x, y), data = grid, inherit.aes = FALSE) +
> ##D   coord_equal() +
> ##D   facet_wrap(~ method) + xlim(-1.1, 1.1) + ylim(-1.1, 1.1) +
> ##D    theme(legend.position = "bottom")
> ##D 
> ##D ## projecting a dataset - rvnorm
> ##D ########################################
> ##D 
> ##D library("ggplot2")
> ##D library("dplyr")
> ##D 
> ##D 
> ##D (p <- mpoly::lissajous(5, 5, 0, 0))
> ##D ggplot() +
> ##D   geom_variety(poly = p, n = 501, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   coord_equal() +
> ##D    theme(legend.position = "bottom")
> ##D set.seed(1)
> ##D (samps <- rvnorm(1e4, p, sd = .025, output = "tibble"))
> ##D 
> ##D ggplot(samps, aes(x, y)) +
> ##D   geom_point(aes(color = .chain)) +
> ##D   coord_equal() +
> ##D   facet_wrap(~ .chain)
> ##D 
> ##D ggplot(samps, aes(x, y)) +
> ##D   geom_bin2d(binwidth = .03*c(1,1)) +
> ##D   coord_equal()
> ##D 
> ##D # cut down on draws for time
> ##D subsamps <- samps |> sample_n(500)
> ##D ggplot(subsamps, aes(x, y)) + geom_point() + coord_equal()
> ##D 
> ##D subsamps |>
> ##D   select(x, y) |>
> ##D   as.matrix() |>
> ##D   apply(1, function(x0) project_onto_variety_lagrange(x0, p)) |> t() |>
> ##D   as.data.frame() |> tibble::as_tibble() |>
> ##D   purrr::set_names(c("x_proj", "y_proj")) |>
> ##D   (\(df_proj) bind_cols(subsamps, df_proj))() ->
> ##D subsamps
> ##D  ggplot() +
> ##D   geom_variety(poly = p, n = 501, xlim = c(-2, 2), ylim = c(-2, 2)) +
> ##D   coord_equal() +
> ##D    theme(legend.position = "bottom") +
> ##D   geom_segment(
> ##D     aes(x, y, xend = x_proj, yend = y_proj),
> ##D     data = subsamps, inherit.aes = FALSE
> ##D   ) +
> ##D   geom_point(
> ##D     aes(x, y, color = factor(.chain)),
> ##D     data = subsamps, inherit.aes = FALSE
> ##D   )
> ##D 
> ##D ggplot(subsamps, aes(x_proj, y_proj)) + geom_point() + coord_equal()
> ##D 
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("project-onto-variety", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("rvnorm")
> ### * rvnorm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rvnorm
> ### Title: The Variety Normal Distribution
> ### Aliases: rvnorm
> 
> ### ** Examples
> 
> 
> 
> library("tidyverse")
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.2     ✔ tibble    3.3.0
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> options("mc.cores" = parallel::detectCores() - 1)
> 
> ## Not run: 
> ##D ## basic usage
> ##D ########################################
> ##D 
> ##D # single polynomial
> ##D p <- mp("x^2 + y^2 - 1")
> ##D samps <- rvnorm(1000, p, sd = .05)
> ##D head(samps)
> ##D str(samps)
> ##D plot(samps, asp = 1)
> ##D 
> ##D # returning a data frame
> ##D (samps <- rvnorm(5000, p, sd = .05, w = 2, output = "tibble"))
> ##D 
> ##D ggplot(samps, aes(x, y)) +
> ##D   geom_point(size = .5) +
> ##D   coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y)) +
> ##D   geom_point(size = .5) +
> ##D   geom_variety(poly = p) +
> ##D   coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y)) +
> ##D   geom_point(aes(color = factor(.chain))) +
> ##D   geom_variety(poly = p, linewidth = 1) +
> ##D   coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y)) +
> ##D   stat_density2d(
> ##D     aes(fill = after_stat(density)),
> ##D     geom = "raster", contour = FALSE
> ##D    ) +
> ##D   geom_variety(poly = p) +
> ##D   coord_equal()
> ##D 
> ##D library("ggdensity")
> ##D ggplot(samps, aes(x, y)) +
> ##D   geom_hdr(xlim = c(-2,2), ylim = c(-2,2)) +
> ##D   geom_variety(poly = p) +
> ##D   coord_equal()
> ##D 
> ##D # in three variables
> ##D (samps <- rvnorm(20, mp("x^2 + y^2 + z^2 - 1"), sd = .05, w = 2))
> ##D apply(samps, 1, function(v) sqrt(sum(v^2)))
> ##D 
> ##D # more than one polynomial, # vars > # eqns, underdetermined system
> ##D p <- mp(c("x^2 + y^2 + z^2 - 1", "z"))
> ##D (samps <- rvnorm(500, p, sd = .1, output = "tibble"))
> ##D ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y, color = `g[1]`)) + geom_point() +
> ##D   scale_color_gradient2(mid = "gray80") + coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y, color = `g[2]`)) + geom_point() +
> ##D   scale_color_gradient2(mid = "gray80") + coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, z, color = `g[1]`)) + geom_point() +
> ##D   scale_color_gradient2(mid = "gray80") + coord_equal()
> ##D 
> ##D # more than one polynomial, # vars < # eqns, overdetermined system
> ##D p <- mp(c("3 x", "3 y", "2 x + 2 y", "3 (x^2 + y)", "3 (x^2 - y)"))
> ##D (samps <- rvnorm(500, p, sd = .1, output = "tibble"))
> ##D 
> ##D samps |>
> ##D   select(x, y, starts_with("g")) |>
> ##D   pivot_longer(starts_with("g"), names_to = "equation", values_to = "value") |>
> ##D   ggplot(aes(x, y, color = value)) + geom_point() +
> ##D     scale_color_gradient2(mid = "gray80") + coord_equal() +
> ##D     facet_wrap(~ equation)
> ##D 
> ##D ## using refresh to get more info
> ##D ########################################
> ##D 
> ##D rvnorm(2000, p, sd = .1, "tibble", verbose = TRUE)
> ##D rvnorm(2000, p, sd = .1, "tibble", refresh = 500)
> ##D rvnorm(2000, p, sd = .1, "tibble", refresh = 0) # default
> ##D rvnorm(2000, p, sd = .1, "tibble", refresh = -1)
> ##D 
> ##D ## many chains in parallel
> ##D ########################################
> ##D 
> ##D options(mc.cores = parallel::detectCores())
> ##D p <- mp("x^2 + (4 y)^2 - 1")
> ##D (samps <- rvnorm(1e4, p, sd = .01, "tibble", verbose = TRUE, chains = 8))
> ##D ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .01*c(1,1)) + coord_equal()
> ##D # decrease sd to get more uniform sampling
> ##D 
> ##D ## windowing for unbounded varieties
> ##D ########################################
> ##D # windowing is needed for unbounded varieties
> ##D # in the following, look at the parameters block
> ##D 
> ##D p <- mp("x y - 1") # unbounded variety, 1 poly
> ##D p <- mp(c("x y - 1", "y - x")) # 2 polys
> ##D 
> ##D rvnorm(1e3, p, sd = .01, "tibble", code_only = TRUE)
> ##D rvnorm(1e3, p, sd = .01, "tibble",  w = 1.15)
> ##D 
> ##D window <- list("x" = c(-1.5, 1.5))
> ##D rvnorm(1e3, p, sd = .01, "tibble",  w = window)
> ##D 
> ##D ## the importance of normalizing
> ##D ########################################
> ##D # one of the effects of the normalizing is to stabilize variances, making
> ##D # them roughly equivalent globally over the variety.
> ##D 
> ##D # lemniscate of bernoulli
> ##D p <- mp("(x^2 + y^2)^2 - 2 (x^2 - y^2)")
> ##D 
> ##D # normalized, good
> ##D (samps <- rvnorm(2000, p, .05, "tibble"))
> ##D ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()
> ##D ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()
> ##D 
> ##D # unnormalized, bad
> ##D (samps <- rvnorm(2000, p, .05, "tibble", homo = FALSE))
> ##D ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()
> ##D ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()
> ##D 
> ##D ## semi-algebraic sets
> ##D ########################################
> ##D # inside the semialgebraic set x^2 + y^2 <= 1
> ##D # this is the same as x^2 + y^2 - 1 <= 0, so that
> ##D # x^2 + y^2 - 1 + s^2 == 0 for some slack variable s
> ##D # this is the projection of the sphere into the xy-plane.
> ##D 
> ##D p <- mp("1 - (x^2 + y^2) - s^2")
> ##D samps <- rvnorm(1e4, p, sd = .1, "tibble", chains = 8, refresh = 1e3)
> ##D ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()
> ##D 
> ##D ggplot(sample_n(samps, 2e3), aes(x, y, color = s)) +
> ##D   geom_point(size = .5) +
> ##D   scale_color_gradient2() +
> ##D   coord_equal()
> ##D 
> ##D # alternative representation
> ##D # x^2 + y^2 - 1 <= 0 iff s^2 (x^2 + y^2 - 1) + 1 == 0
> ##D # note that it's gradient is more complicated.
> ##D p <- mp("s^2 (x^2 + y^2 - 1) + 1")
> ##D samps <- rvnorm(1e4, p, sd = .1, "tibble", chains = 8, w = 2, refresh = 1e3)
> ##D ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()
> ##D 
> ##D ## keeping the warmup / the importance of multiple chains
> ##D ########################################
> ##D 
> ##D p <- mp("((x + 1.5)^2 + y^2 - 1) ((x - 1.5)^2 + y^2 - 1)")
> ##D ggplot() +
> ##D   geom_variety(poly = p, xlim = c(-3,3)) +
> ##D   theme(legend.position = "top") +
> ##D   coord_equal()
> ##D 
> ##D # notice the migration of chains initialized away from the distribution
> ##D # (it helps to make the graphic large on your screen)
> ##D samps <- rvnorm(500, p, sd = .05, "tibble", chains = 8, inc_warmup = TRUE)
> ##D 
> ##D ## ideal-variety correspondence considerations
> ##D ########################################
> ##D 
> ##D p <- mp("x^2 + y^2 - 1")
> ##D 
> ##D samps_1 <- rvnorm(250, p^1, sd = .1, output = "tibble", chains = 8)
> ##D samps_2 <- rvnorm(250, p^2, sd = .1, output = "tibble", chains = 8)
> ##D samps_3 <- rvnorm(250, p^3, sd = .1, output = "tibble", chains = 8)
> ##D samps_4 <- rvnorm(250, p^4, sd = .1, output = "tibble", chains = 8)
> ##D samps <- bind_rows(mget(apropos("samps_[1-4]")))
> ##D samps$power <- rep(seq_along(apropos("samps_[1-4]")), each = 250)
> ##D 
> ##D ggplot(samps, aes(x, y, color = g < 0)) +
> ##D   geom_point(size = .5) +
> ##D   coord_equal(xlim = c(-3,3), ylim = c(-3,3)) +
> ##D   facet_wrap(~ power)
> ##D 
> ##D ## neat examples
> ##D ########################################
> ##D # an implicit Lissajous region, view in separate window large
> ##D 
> ##D # x = cos(m t + p)
> ##D # y = sin(n t + q)
> ##D (p <- lissajous(3, 2,  -pi/2, 0))
> ##D (p <- lissajous(4, 3,  -pi/2, 0))
> ##D (p <- lissajous(5, 4,  -pi/2, 0))
> ##D (p <- lissajous(3, 3,  0, 0))
> ##D (p <- lissajous(5, 5,  0, 0))
> ##D (p <- lissajous(7, 7,  0, 0))
> ##D ggplot() +
> ##D   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2), n = 201,
> ##D   show.legend = FALSE) +
> ##D   coord_equal()
> ##D 
> ##D p <- plug(p, "x", mp(".5 x"))
> ##D p <- plug(p, "y", mp(".5 y"))
> ##D 
> ##D # algebraic set
> ##D samps <- rvnorm(5e3, p, sd = .01, "tibble", chains = 8, cores = 8)
> ##D ggplot(samps, aes(x, y, color = factor(.chain))) +
> ##D   geom_point(size = .5) +
> ##D   coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y)) + geom_hdr() + coord_equal()
> ##D 
> ##D ggplot(samps, aes(x, y, color = factor(.chain))) +
> ##D   geom_point(size = .5) +
> ##D   coord_equal() +
> ##D   facet_wrap(~ factor(.chain))
> ##D 
> ##D # semi-algebraic set
> ##D samps_normd <- rvnorm(1e4, p + mp("s^2"), sd = .01, "tibble", chains = 8,
> ##D   cores = 8, homo = TRUE
> ##D )
> ##D samps_unormd <- rvnorm(1e4, p + mp("s^2"), sd = .01, "tibble", chains = 8,
> ##D   cores = 8, homo = FALSE
> ##D )
> ##D 
> ##D bind_rows(
> ##D   samps_normd  |> mutate(normd = TRUE),
> ##D   samps_unormd |> mutate(normd = FALSE)
> ##D ) |>
> ##D   ggplot(aes(x, y)) +
> ##D     geom_point(size = .5) +
> ##D     # geom_bin2d(binwidth = .05*c(1,1)) +
> ##D     facet_grid(normd ~ .chain) +
> ##D     coord_equal()
> ##D 
> ##D ggplot(samps_normd, aes(x, y)) +
> ##D   geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rvnorm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:lubridate’, ‘package:forcats’, ‘package:stringr’,
  ‘package:dplyr’, ‘package:purrr’, ‘package:readr’, ‘package:tidyr’,
  ‘package:tibble’, ‘package:ggplot2’, ‘package:tidyverse’

> nameEx("variety_solve")
> ### * variety_solve
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: variety_solve
> ### Title: Solve a Zero-Dimensional Variety
> ### Aliases: variety_solve
> 
> ### ** Examples
> 
> library(mpoly)
> ## Not run: 
> ##D f1 <- mp("x^2 - y")
> ##D f2 <- mp("x^2 + y")
> ##D polylist <- mpolyList(f1, f2)
> ##D 
> ##D # Posterior-mean solution only
> ##D variety_solve(polylist, n = 2e4, sd = 0.01, sig_digit = 3)
> ##D 
> ##D # Return Stan fit and solution
> ##D out <- variety_solve(polylist, n = 1e4, stanfit = TRUE)
> ##D out
> ##D 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("variety_solve", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:mpoly’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.503 0.117 3.681 0.002 0.004 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
