# Projection onto a Variety

An R-based implementation of gradient-descent homotopies with adaptive
step sizes for Euler prediction. The Lagrange version uses Newton's
method on the Lagrangian system.

## Usage

``` r
project_onto_variety(
  x0,
  poly,
  dt = 0.01,
  varorder = sort(mpoly::vars(poly)),
  n_correct = 2,
  al = rnorm(2),
  message = FALSE,
  tol = .Machine$double.eps^(1/2),
  gfunc,
  dgfunc,
  ddgfunc,
  bias = 0,
  adaptive = TRUE,
  dt_min = 1e-06,
  dt_max = 0.1,
  error_tol = 0.01
)

project_onto_variety_lagrange(
  x0,
  poly,
  varorder = mpoly::vars(poly),
  method = "newton",
  maxit = 1000,
  tol = .Machine$double.eps^(1/2),
  tol_x = .Machine$double.eps^(1/2),
  message = FALSE,
  ...
)

project_onto_variety_gradient_descent(
  x0,
  poly,
  varorder = mpoly::vars(poly),
  ga = 0.01,
  max_ga = 0.1,
  method = c("line", "optimal", "fixed"),
  tol = .Machine$double.eps^(1/2),
  tol_x = .Machine$double.eps^(1/2),
  maxit = 1000,
  message = FALSE
)

project_onto_variety_newton(
  x0,
  poly,
  varorder = mpoly::vars(poly),
  ga = 1e-04,
  max_ga = 2,
  method = c("line", "fixed"),
  tol = .Machine$double.eps^(1/2),
  tol_x = .Machine$double.eps^(1/2),
  maxit = 1000,
  message = FALSE
)
```

## Arguments

- x0:

  A numeric vector giving one point to be projected, or a numeric
  matrix/data frame whose rows are points to be projected.

- poly:

  An `mpoly` object, typically created with
  [`mpoly::mp()`](https://rdrr.io/pkg/mpoly/man/mp.html).

- dt:

  The t-mesh size for the homotopy.

- varorder:

  A character vector specifying the variable order to pass to
  [`mpoly::as.function.mpoly()`](https://rdrr.io/pkg/mpoly/man/as-function.html).

- n_correct:

  The number of Newton correction iterations to use.

- al:

  A numeric vector of length 2; the patch to do projective calculations
  over.

- message:

  If `TRUE`, the user is issued messages on the algorithm's progress.

- tol:

  A tolerance on the residual; a warning is issued if the magnitude of
  the residual is larger than `tol`.

- gfunc, dgfunc, ddgfunc:

  The polynomial [poly](https://rdrr.io/r/stats/poly.html), its
  gradient, and its Hessian as functions. Only used in
  `project_onto_variety()`, and computed internally if not provided.

- bias:

  A multiple to add to the identity to make the Jacobian invertible.

- adaptive:

  Defaults to `TRUE`. Whether to use adaptive step sizes.

- dt_min, dt_max:

  Minimum and maximum allowed step sizes during adaptive integration
  (default: `1e-6` and `0.1`).

- error_tol:

  Tolerance used for adaptive step size control (default: `0.01`).
  Smaller values give more accurate results at the cost of runtime.

- method:

  Used in `project_onto_variety_lagrange()`,
  `project_onto_variety_gradient_descent()`, and
  `project_onto_variety_newton()`. In the Lagrange method, if
  `"newton"`, a simple R implementation of Newton's method to solve the
  nonlinear algebraic system generated by the Lagrangian; otherwise, a
  character string to pass to
  [`stats::optim()`](https://rdrr.io/r/stats/optim.html) to minimize the
  sum of the squares of the Lagrangian. In the gradient-descent and
  Newton methods, `method` controls the line-search/fixed-step update:
  `"line"` (line search), `"optimal"`, or `"fixed"`.

- maxit:

  Number of maximum iterations in solving Newton's method.

- tol_x:

  A tolerance on subsequent step sizes.

- ...:

  Additional arguments to pass to
  [`stats::optim()`](https://rdrr.io/r/stats/optim.html) when `method`
  is not `"newton"`.

- ga:

  Learning rate for gradient descent.

- max_ga:

  Maximum learning rate for gradient descent line search.

## Value

If `x0` is a vector, a numeric vector the same length as `x0`. If `x0`
is a matrix/data frame, a matrix/data frame of projected points with the
same number of rows.

## References

Griffin, Z. and J. Hauenstein (2015). Real solutions to systems of
polynomial equations and parameter continuation. *Advances in Geometry*
15(2), pp.173–187.

Bates, D., J. Hauenstein, A. Sommese, and C. Wampler (2013). Numerically
Solving Polynomial Systems with Bertini. SIAM. pp.34–35.

## Author

David Kahle

## Examples

``` r
library("ggplot2")
library("mpoly")

if (FALSE) { # \dontrun{
## basic usage
x0 <- c(1, 1)
p1 <- mp("x^2 + y^2 - 1")
x1_proj <- project_onto_variety(x0, p1)
x1_proj

# Residual on the variety should be near zero
as.function(p1)(x1_proj)

df1 <- data.frame(
  x = x0[1], y = x0[2],
  x_proj = x1_proj[1], y_proj = x1_proj[2]
)
ggplot() +
  geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2)) +
  geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df1) +
  coord_equal()

## adaptive time stepping (default) versus fixed step size
x2_adapt <- project_onto_variety(x0, p1)
x2_fixed <- project_onto_variety(x0, p1, adaptive = FALSE, dt = 0.01)
x2_strict <- project_onto_variety(x0, p1, error_tol = 0.001)

rbind(
  adaptive = x2_adapt,
  fixed = x2_fixed,
  adaptive_strict = x2_strict
)

# Optional: inspect adaptive step messages
project_onto_variety(x0, p1, message = TRUE)

## precomputing polynomial/gradient/Hessian functions
varorder <- c("x", "y")
gfunc <- as.function(p1, varorder = varorder)
dg <- stats::deriv(p1, var = varorder)
dgfunc <- as.function(dg, varorder = varorder)
ddg <- lapply(dg, stats::deriv, var = varorder)
ddgfunc_list <- lapply(ddg, as.function, varorder = varorder, silent = TRUE)
ddgfunc <- function(x) sapply(ddgfunc_list, function(f) f(x))
project_onto_variety(x0, p1, gfunc = gfunc, dgfunc = dgfunc, ddgfunc = ddgfunc)

## projecting multiple points (matrix or data frame input)
x2 <- rbind(c(1, 1), c(-1, 0.3), c(0.2, -1.3))
project_onto_variety(x2, p1)
project_onto_variety(as.data.frame(x2), p1)

## alternative projection methods
project_onto_variety_lagrange(x0, p1)
project_onto_variety_newton(x0, p1)
project_onto_variety_gradient_descent(x0, p1, method = "line")
project_onto_variety_gradient_descent(x0, p1, method = "optimal")
project_onto_variety_gradient_descent(x0, p1, method = "fixed")

## naive usages / method comparison on a small grid
# (gradient descent methods minimize g(x)^2 directly)
library("dplyr")
set.seed(1)
grid <- expand.grid(x = seq(-1, 1, by = 0.5), y = seq(-1, 1, by = 0.5))
grid$x <- jitter(grid$x)
grid$y <- jitter(grid$y)

proj_homotopy <- project_onto_variety(grid, p1)
proj_gd_opt <- project_onto_variety_gradient_descent(grid, p1, method = "optimal")
proj_newton <- project_onto_variety_newton(grid, p1)

names(proj_homotopy) <- c("x_proj", "y_proj")
names(proj_gd_opt) <- c("x_proj", "y_proj")
names(proj_newton) <- c("x_proj", "y_proj")

df_cmp <- bind_rows(
  bind_cols(grid, proj_homotopy) |> mutate(method = "homotopy (adaptive default)"),
  bind_cols(grid, proj_gd_opt)   |> mutate(method = "naive gd on g^2 (optimal)"),
  bind_cols(grid, proj_newton)   |> mutate(method = "newton on g^2")
)

ggplot() +
  geom_variety(poly = p1, xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2)) +
  geom_segment(
    aes(x, y, xend = x_proj, yend = y_proj),
    data = df_cmp, inherit.aes = FALSE, alpha = 0.6
  ) +
  geom_point(aes(x, y), data = grid, inherit.aes = FALSE, size = 0.8) +
  coord_equal() +
  facet_wrap(~ method)

## changing adaptive control parameters
project_onto_variety(
  x0, p1,
  adaptive = TRUE,
  dt = 0.05,
  dt_min = 1e-5,
  dt_max = 0.2,
  error_tol = 0.005,
  message = TRUE
)

## more complex curve
p_complex <- mp("(x^2 + y^2)^2 - 2 * (x^2 - y^2)")
x_complex <- c(1, 1)
x_complex_proj <- project_onto_variety(x_complex, p_complex)
df_complex <- data.frame(
  x = x_complex[1], y = x_complex[2],
  x_proj = x_complex_proj[1], y_proj = x_complex_proj[2]
)
ggplot() +
  geom_variety(poly = p_complex, xlim = c(-2, 2), ylim = c(-2, 2)) +
  geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df_complex) +
  coord_equal()

## projecting a sample from rvnorm (batch usage)
# cut down on draws for example runtime
samps <- rvnorm(500, p1, sd = 0.05, output = "tibble")
idx <- sample(seq_len(nrow(samps)), size = min(75, nrow(samps)))
subsamps <- samps[idx, , drop = FALSE]
proj_sub <- project_onto_variety(subsamps[, c("x", "y")], p1)
names(proj_sub) <- c("x_proj", "y_proj")
df_sub <- dplyr::bind_cols(subsamps, proj_sub)

ggplot(df_sub, aes(x, y)) +
  geom_segment(aes(xend = x_proj, yend = y_proj), alpha = 0.4) +
  geom_point(size = 0.8) +
  geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2), inherit.aes = FALSE) +
  coord_equal()

## higher-dimensional example
x3 <- c(1, 1, 1)
p2 <- mp("x^2 + y^2 + z^2 - 1")
project_onto_variety(x3, p2)
} # }
```
