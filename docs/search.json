[{"path":"https://sonish13.github.io/vnorm/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 vnorm authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://sonish13.github.io/vnorm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sonish Lamsal. Author. David Kahle. Author, maintainer.","code":""},{"path":"https://sonish13.github.io/vnorm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lamsal S, Kahle D (2026). vnorm: Variety Normal Distribution. R package version 0.0.0.9000, https://sonish13.github.io/vnorm/.","code":"@Manual{,   title = {vnorm: Variety Normal Distribution},   author = {Sonish Lamsal and David Kahle},   year = {2026},   note = {R package version 0.0.0.9000},   url = {https://sonish13.github.io/vnorm/}, }"},{"path":"https://sonish13.github.io/vnorm/index.html","id":null,"dir":"","previous_headings":"","what":"Variety Normal Distribution","title":"Variety Normal Distribution","text":"CRAN status vnorm provides tools sampling, visualizing, projecting near real algebraic varieties defined polynomial equations. implements variety normal distribution using mpoly polynomial representations Stan-based samplers. addition sampling rvnorm(), package includes pseudo-density evaluation via pdvnorm(), ggplot2 visualization geom_variety(), projection onto varieties project_onto_variety().","code":""},{"path":"https://sonish13.github.io/vnorm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Variety Normal Distribution","text":"can install development version vnorm GitHub : rvnorm() uses Stan/HMC primary sampling backend, install cmdstanr CmdStan normal package use. rejection sampler interface also available (rejection = TRUE) can useful quick examples simple low-dimensional cases.","code":"if (!requireNamespace(\"devtools\")) install.packages(\"devtools\") devtools::install_github(\"dkahle/mpoly\") devtools::install_github(\"sonish13/vnorm\")"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"quick-start-sample-and-plot-a-variety","dir":"","previous_headings":"","what":"Quick Start: Sample and Plot a Variety","title":"Variety Normal Distribution","text":"main workflow : define polynomial variety, sample near rvnorm(), visualize geom_variety(). Stan/HMC (primary path):","code":"p1 <- mp(\"x^2 + y^2 - 1\") samps1 <- rvnorm(   2000,   poly = p1,   sd = 0.1,   output = \"tibble\" )  ggplot(samps1, aes(x, y)) +   geom_point(size = 0.4) +   geom_variety(poly = p1, inherit.aes = FALSE, show.legend = FALSE) +   coord_equal() +   theme_minimal()"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"main-functions","dir":"","previous_headings":"","what":"Main Functions","title":"Variety Normal Distribution","text":"rvnorm() samples variety normal distribution near polynomial variety. pdvnorm() evaluates pseudo-density (normalizing constant). geom_variety() plots real 1D varieties 2D using ggplot2. project_onto_variety() projects points onto variety. compile_stan_code() pre-compiles reusable Stan models repeated sampling related polynomial forms.","code":""},{"path":"https://sonish13.github.io/vnorm/index.html","id":"rvnorm-the-main-sampling-function","dir":"","previous_headings":"Main Functions","what":"rvnorm(): the main sampling function","title":"Variety Normal Distribution","text":"rvnorm() main entry point sampling near varieties defined one polynomial (mpoly) system polynomials (mpolyList). supports: Stan/HMC sampling (default; best serious use) rejection sampling (rejection = TRUE; good quick examples simple cases) built-pre-compiled Stan models (pre_compiled = TRUE) common polynomial structures user pre-compiled Stan models (user_compiled = TRUE) repeated sampling related polynomial forms Common arguments: poly: polynomial polynomial system defining target variety sd / Sigma: controls concentration around variety output: output format (example \"tibble\") w: window size unbounded varieties (rejection sampling) rejection: use rejection sampler instead Stan/HMC Stan/HMC path default recommended mode use. rejection sampler available lighter-weight alternative low dimensional examples. Default Stan/HMC usage: Typical default workflow (sample, visualize), shown : Additional common rvnorm() usage patterns: Rejection sampler usage (alternative path; currently wrapper supports scalar sd):","code":"p2 <- mp(\"x^2 + y^2 - 1\") samps2 <- rvnorm(2000, poly = p2, sd = 0.1, output = \"tibble\") p2 <- mp(\"x^2 + y^2 - 1\") samps2 <- rvnorm(2000, poly = p2, sd = 0.1, output = \"tibble\")  ggplot(samps2, aes(x, y)) +   geom_point(size = 0.5, alpha = 0.35) +   geom_variety(poly = p2, inherit.aes = FALSE) +   coord_equal() # Use a packaged pre-compiled Stan model when available (small degree/variable cases) rvnorm(2000, mp(\"x^2 + y^2 + z^2 - 1\"), sd = 0.1, pre_compiled = TRUE)  # Unbounded varieties typically need a window parameter w rvnorm(2000, mp(\"x y - 1\"), sd = 0.1, w = 2, output = \"tibble\")  # Multi-polynomial systems (underdetermined / overdetermined are both supported) rvnorm(2000, mp(c(\"x^2 + y^2 + z^2 - 1\", \"z\")), sd = 0.1, output = \"tibble\")  # Use Sigma for anisotropic concentration (single polynomial) rvnorm(2000, mp(\"x^2 + y^2 - 1\"), Sigma = diag(c(0.02, 0.10)^2), output = \"tibble\")  # Use Sigma with polynomial systems as well rvnorm(2000, mp(c(\"x^2 + y^2 - 1\", \"x y - 0.25\")), Sigma = diag(c(0.05, 0.08)^2)) set.seed(1) p3 <- mp(c(\"x^2 + y^2 - 1\", \"x y - 0.25\")) samps3 <- rvnorm(   2000,   poly = p3,   sd = 0.1,   rejection = TRUE,   w = 1.5,   output = \"tibble\" )  ggplot(samps3, aes(x, y)) +   geom_point(size = 0.5, alpha = 0.4) +   geom_variety(poly = p3, xlim = c(-2, 2), ylim = c(-2, 2), inherit.aes = FALSE) +   coord_equal() +   theme_minimal()"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"pdvnorm-pseudo-density-evaluation","dir":"","previous_headings":"Main Functions","what":"pdvnorm(): pseudo-density evaluation","title":"Variety Normal Distribution","text":"pdvnorm() can used single polynomials polynomial systems, supports scalar, vector, matrix sigma inputs depending setting.","code":"p4 <- mp(c(\"x^2 + y^2 - 1\", \"x y - 0.25\")) x1 <- c(0.8, 0.3)  pdvnorm(x1, p4, sigma = 1) #> [1] 0.1560083 pdvnorm(x1, p4, sigma = c(1, 2), homo = FALSE) #> [1] 0.1085086 pdvnorm(x1, p4, sigma = diag(c(1, 4))) #> [1] 0.07810636"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"geom_variety-ggplot2-compatible-variety-plots","dir":"","previous_headings":"Main Functions","what":"geom_variety(): ggplot2-compatible variety plots","title":"Variety Normal Distribution","text":"geom_variety() supports single-polynomial (mpoly) multi-polynomial (mpolyList) inputs works standard ggplot2 themes/scales.   squared polynomial (example, p^2) produces contour shift = 0, geom_variety() prints suggested negative shift. Using shift can help recover plotted zero set -sign-change cases.","code":"p5 <- mp(\"(x^2 + y^2)^2 - 2 (x^2 - y^2)\")  ggplot() +   geom_variety(poly = p5, xlim = c(-2, 2), ylim = c(-2, 2), show.legend = FALSE) +   coord_equal() +   theme_minimal() p6 <- mp(c(\"x^2 + y^2 - 1\", \"x y - 0.25\"))  ggplot() +   geom_variety(     poly = p6,     xlim = c(-2, 2),     ylim = c(-2, 2),     vary_colour = TRUE   ) +   coord_equal() +   scale_colour_manual(values = c(\"steelblue\", \"firebrick\")) +   theme_minimal() +   theme(legend.position = \"top\") p7 <- mp(\"y^2 - x^2\") ggplot() +   geom_variety(poly = p7^2, xlim = c(-2, 2), ylim = c(-2, 2)) +   coord_equal() #> All values are positive on the plotting grid; try shift = -0.000959513. #> Zero contours were generated p7 <- mp(\"y^2 - x^2\") ggplot() +   geom_variety(     poly = p7^2,     xlim = c(-2, 2), ylim = c(-2, 2),     shift = -0.000959513,     show.legend = FALSE   ) +   coord_equal() +   theme_minimal()"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"project_onto_variety-projection-with-visualization","dir":"","previous_headings":"Main Functions","what":"project_onto_variety(): projection with visualization","title":"Variety Normal Distribution","text":"projection functions useful snapping points back variety inspecting projection behavior visually.  red point starting value black point projection onto variety. grey segment shows displacement starting point projected point. Adaptive time stepping used default. comparison illustrates homotopy projection path starting point using fixed step sizes versus adaptive step sizes (similar paper figure). open circles mark successive iterates along path.  panel, black curve target variety (ellipse segment), connected black path homotopy projection path starting point, open circles show successive iterates. adaptive method default typically reaches variety fewer steps maintaining error tolerance.","code":"p8 <- mp(\"x^2 + y^2 - 0.25\") x0 <- c(1.3, 0.9) (x0_proj <- project_onto_variety(x0, p8)) #> [1] 0.4110961 0.2846050"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"pre-compiled-models","dir":"","previous_headings":"","what":"Pre-compiled Models","title":"Variety Normal Distribution","text":"vnorm includes pre-compiled Stan models common polynomial structures (three variables total degree three). repeated work custom polynomial form, use compile_stan_code() call rvnorm() user_compiled = TRUE related polynomials different coefficients.","code":"p_template <- mp(\"x^4 + y^4 - 1\") compile_stan_code(poly = p_template)  p_new <- mp(\"2 x^4 + 3 y^4 - 1\") samps_new <- rvnorm(1000, poly = p_new, sd = 0.1, user_compiled = TRUE)"},{"path":"https://sonish13.github.io/vnorm/index.html","id":"learn-more","dir":"","previous_headings":"","what":"Learn More","title":"Variety Normal Distribution","text":"README focuses main user-facing workflow: sample, visualize, evaluate, project. longer manuscript mathematical background additional examples preparation shared separately.","code":""},{"path":"https://sonish13.github.io/vnorm/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Variety Normal Distribution","text":"Kahle, David Hauenstein, Jonathan D. (2024). Stochastic Exploration Real Varieties via Variety Distributions. arXiv:2410.16071 Griffin, Zachary . Hauenstein, Jonathan D. (2015). Real solutions systems polynomial equations parameter continuation. Advances Geometry, 15(2), 173–187. doi:10.1515/advgeom-2015-0004 Schenck, Henry (2015). Book Review: Numerically solving polynomial systems Bertini. Bulletin American Mathematical Society, 53(1), 179–186. doi:10.1090/bull/1520","code":""},{"path":"https://sonish13.github.io/vnorm/reference/compile_stan_code.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a Stan Model for User-Defined Polynomials — compile_stan_code","title":"Compile a Stan Model for User-Defined Polynomials — compile_stan_code","text":"Compile cache Stan model template polynomial shape repeated calls rvnorm() can reuse compiled binary.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/compile_stan_code.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a Stan Model for User-Defined Polynomials — compile_stan_code","text":"","code":"compile_stan_code(poly, custom_stan_code = FALSE, w = FALSE, homo = TRUE)"},{"path":"https://sonish13.github.io/vnorm/reference/compile_stan_code.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a Stan Model for User-Defined Polynomials — compile_stan_code","text":"poly mpoly mpolyList object. custom_stan_code TRUE, custom model compiled even general case polynomial already included package installation. Defaults FALSE. w named list box constraints vectors passed Stan. See rvnorm() examples. Defaults FALSE. homo TRUE, sampling done homoskedastic variety normal distribution. Defaults TRUE. compiled model metadata stored internal package cache used rvnorm() user_compiled = TRUE.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/compile_stan_code.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile a Stan Model for User-Defined Polynomials — compile_stan_code","text":"","code":"if (FALSE) { # \\dontrun{ # compile a model that looks like b0 + bx6 x^6 + by6 y^6 for later input p <- mp(\"x^6 + y^6 - 1\") # template polynomial samps <- rvnorm(1000, p, sd = .05) head(samps) compile_stan_code(p) # allows to change coefficients p <- mp(\"x^6 + 8 y^6 - 1\") rvnorm(1e4, p, .05, user_compiled = TRUE)  } # }"},{"path":"https://sonish13.github.io/vnorm/reference/geom_variety.html","id":null,"dir":"Reference","previous_headings":"","what":"One-Dimensional Varieties in Two Dimensions — geom_variety","title":"One-Dimensional Varieties in Two Dimensions — geom_variety","text":"Plot implicit polynomial varieties ggplot2.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/geom_variety.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-Dimensional Varieties in Two Dimensions — geom_variety","text":"","code":"stat_variety(   mapping = NULL,   data = NULL,   geom = GeomVariety,   position = \"identity\",   ...,   poly = NULL,   n = 101,   nx = n,   ny = n,   xlim = NULL,   ylim = NULL,   shift = 0,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_variety(   mapping = NULL,   data = NULL,   stat = \"variety\",   position = \"identity\",   ...,   poly,   vary_colour = FALSE,   shift = 0,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"https://sonish13.github.io/vnorm/reference/geom_variety.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-Dimensional Varieties in Two Dimensions — geom_variety","text":"mapping Aesthetic mappings created ggplot2::aes(). data Layer data. geom geometric object used display data; defaults GeomVariety. position Position adjustment layer. ... Additional parameters forwarded ggplot2::layer(). poly mpoly mpolyList object describing implicit polynomial(s) plot. n Number grid points used x y directions nx ny supplied. nx, ny Number grid points x y directions. xlim, ylim Length-2 numeric vectors giving plotting limits. supplied, limits taken plot scales. shift numeric constant added evaluated surface contouring, .e. plotted level set poly + shift = 0. mainly useful polynomial cross zero plotting grid (example, p^2). shift = 0 sampled values one sign, geom_variety() prints message suggesting shift value. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. include legend keys levels, even data exists, use TRUE.  NA, levels shown legend, unobserved levels omitted. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. annotation_borders(). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. vary_colour Logical. TRUE, map colour polynomial label users can control per-polynomial colours scale_colour_*(). Defaults FALSE, keeps constant line colour varies linetype across mpolyList.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/geom_variety.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"One-Dimensional Varieties in Two Dimensions — geom_variety","text":"geom_variety() understands following aesthetics. x y computed stat, users typically map manually: x y alpha color group linetype linewidth subgroup","code":""},{"path":"https://sonish13.github.io/vnorm/reference/geom_variety.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed variables","title":"One-Dimensional Varieties in Two Dimensions — geom_variety","text":"Polynomial parseable label polynomial, useful after_stat(Polynomial) mappings (example, linetype colour). group Contour path group identifier used internally layer.","code":""},{"path":[]},{"path":"https://sonish13.github.io/vnorm/reference/geom_variety.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-Dimensional Varieties in Two Dimensions — geom_variety","text":"","code":"library(\"ggplot2\")  # 1) Ellipse p1 <- mp(\"x^2 + 4 y^2 - 1\") ggplot() +   geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2)) +   coord_equal()   # Works with standard ggplot2 styling ggplot() +   geom_variety(     poly = p1, xlim = c(-2, 2), ylim = c(-2, 2),     colour = \"steelblue\", linewidth = 0.5   ) +   coord_equal() +   theme_minimal()   # 2) Folium of Descartes (singular variety) p2 <- mp(\"x^3 + y^3 - 3 x y\") ggplot() +   geom_variety(poly = p2, xlim = c(-2, 3), ylim = c(-2, 3)) +   coord_equal()   # 3) \"Heart\" curve (classic implicit heart) p3 <- mp(\"(x^2 + y^2 - 1)^3 - x^2 y^3\") ggplot() +   geom_variety(poly = p3, xlim = c(-2, 2), ylim = c(-2, 2)) +   coord_equal() +   theme(legend.position = \"top\")   # 4) A 2-polynomial system (mpolyList): circle and xy = 0.25 p4 <- mp(c(\"x^2 + y^2 - 1\", \"x y - 0.25\")) # By default, polynomials differ by linetype (not color). ggplot() +   geom_variety(poly = p4, xlim = c(-2, 2), ylim = c(-2, 2)) +   coord_equal()   # With different colors (optional) ggplot() +   geom_variety(poly = p4, xlim = c(-2, 2), ylim = c(-2, 2), vary_colour = TRUE) +   coord_equal() +   scale_colour_manual(values = c(\"steelblue\", \"firebrick\"))   # You can also customize linetypes and legend placement with ggplot2 scales/themes ggplot() +   geom_variety(poly = p4, xlim = c(-2, 2), ylim = c(-2, 2), vary_colour = TRUE) +   coord_equal() +   scale_colour_manual(values = c(\"steelblue\", \"firebrick\")) +   scale_linetype_manual(values = c(\"solid\", \"22\"), guide = \"none\") +   theme(legend.position = \"top\") #> Scale for linetype is already present. #> Adding another scale for linetype, which will replace the existing scale.   ## common contouring situations ########################################  # 5) Squared polynomial (same zero set, but no sign change on the grid) # geom_variety() will suggest a negative shift when no contour is found. p5 <- mp(\"x^2 + y^2 - 1\") ggplot() +   geom_variety(poly = p5^2, xlim = c(-2, 2), ylim = c(-2, 2)) +   coord_equal() #> All values are positive on the plotting grid; try shift = -0.00101684. #> Zero contours were generated   # Use the suggested shift (your printed value may differ slightly). ggplot() +   geom_variety(poly = p5^2, xlim = c(-2, 2), ylim = c(-2, 2), shift = -0.001) +   coord_equal()"},{"path":"https://sonish13.github.io/vnorm/reference/pdvnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Pseudo-Density for the Variety Normal Distribution — pdvnorm","title":"Pseudo-Density for the Variety Normal Distribution — pdvnorm","text":"Evaluate variety normal pseudo-density either homoskedastic heteroskedastic setting.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/pdvnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pseudo-Density for the Variety Normal Distribution — pdvnorm","text":"","code":"pdvnorm(x, poly, sigma, homo = TRUE, log = FALSE)"},{"path":"https://sonish13.github.io/vnorm/reference/pdvnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pseudo-Density for the Variety Normal Distribution — pdvnorm","text":"x numeric vector length equal number variables poly, numeric matrix/data frame many columns (one row per evaluation point). poly mpoly object (single polynomial) mpolyList object (multiple polynomials). sigma single-polynomial case, positive scalar standard deviation. multi-polynomial case, scalar, vector, matrix. homo = TRUE, sigma must conform number variables; homo = FALSE, must conform number polynomials. homo Logical; default TRUE. TRUE, compute homoskedastic variety normal pseudo-density. FALSE, compute heteroskedastic pseudo-density. log Logical. TRUE, returns log density.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/pdvnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pseudo-Density for the Variety Normal Distribution — pdvnorm","text":"numeric scalar vector containing pseudo-density evaluated x.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/pdvnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pseudo-Density for the Variety Normal Distribution — pdvnorm","text":"","code":"library(\"mpoly\")  ## Single polynomial in one variable p1 <- mp(\"x\") pdvnorm(c(-1, 0, 1), p1, sigma = 1) #> [1] 0.2419707 0.3989423 0.2419707 pdvnorm(0, p1, sigma = 2, log = TRUE) #> [1] -1.612086  ## Multivariate (square) system: two polynomials in two variables p2 <- mp(c(\"x\", \"y\")) x2 <- rbind(c(0, 0), c(1, 2), c(-1, 3))  ## Different sigma forms pdvnorm(x2, p2, sigma = 1) #> [1] 0.15915494 0.05167004 0.09653235 pdvnorm(x2, p2, sigma = c(1, 2)) #> [1] 0.11253954 0.06412310 0.08764588 pdvnorm(x2, p2, sigma = diag(c(1, 4))) #> [1] 0.07957747 0.06006823 0.07022687  ## Multivariate (underdetermined): one polynomial in two variables p3 <- mp(\"x + y\") x3 <- rbind(c(1, 1), c(2, -1), c(0, 3)) pdvnorm(x3, p3, sigma = 1) #> [1] 0.14676266 0.31069656 0.04204821 pdvnorm(as.data.frame(x3), p3, sigma = 1) #> [1] 0.14676266 0.31069656 0.04204821  ## Multivariate (overdetermined): three polynomials in two variables p4 <- mp(c(\"x\", \"y\", \"x + y\")) x4 <- rbind(c(1, 2), c(0, -1), c(2, 2)) pdvnorm(x4, p4, sigma = diag(2),    homo = TRUE) #> [1] 0.05854983 0.14241810 0.02689930 pdvnorm(x4, p4, sigma = c(1, 2, 3), homo = FALSE) #> [1] 0.0012905390 0.0170882873 0.0000896711"},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection onto a Variety — project-onto-variety","title":"Projection onto a Variety — project-onto-variety","text":"R-based implementation gradient-descent homotopies adaptive step sizes Euler prediction. Lagrange version uses Newton's method Lagrangian system.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection onto a Variety — project-onto-variety","text":"","code":"project_onto_variety(   x0,   poly,   dt = 0.01,   varorder = sort(mpoly::vars(poly)),   n_correct = 2,   al = rnorm(2),   message = FALSE,   tol = .Machine$double.eps^(1/2),   gfunc,   dgfunc,   ddgfunc,   bias = 0,   adaptive = TRUE,   dt_min = 1e-06,   dt_max = 0.1,   error_tol = 0.01 )  project_onto_variety_lagrange(   x0,   poly,   varorder = mpoly::vars(poly),   method = \"newton\",   maxit = 1000,   tol = .Machine$double.eps^(1/2),   tol_x = .Machine$double.eps^(1/2),   message = FALSE,   ... )  project_onto_variety_gradient_descent(   x0,   poly,   varorder = mpoly::vars(poly),   ga = 0.01,   max_ga = 0.1,   method = c(\"line\", \"optimal\", \"fixed\"),   tol = .Machine$double.eps^(1/2),   tol_x = .Machine$double.eps^(1/2),   maxit = 1000,   message = FALSE )  project_onto_variety_newton(   x0,   poly,   varorder = mpoly::vars(poly),   ga = 1e-04,   max_ga = 2,   method = c(\"line\", \"fixed\"),   tol = .Machine$double.eps^(1/2),   tol_x = .Machine$double.eps^(1/2),   maxit = 1000,   message = FALSE )"},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection onto a Variety — project-onto-variety","text":"x0 numeric vector giving one point projected, numeric matrix/data frame whose rows points projected. poly mpoly object, typically created mpoly::mp(). dt t-mesh size homotopy. varorder character vector specifying variable order pass mpoly::.function.mpoly(). n_correct number Newton correction iterations use. al numeric vector length 2; patch projective calculations . message TRUE, user issued messages algorithm's progress. tol tolerance residual; warning issued magnitude residual larger tol. gfunc, dgfunc, ddgfunc polynomial poly, gradient, Hessian functions. used project_onto_variety(), computed internally provided. bias multiple add identity make Jacobian invertible. adaptive Defaults TRUE. Whether use adaptive step sizes. dt_min, dt_max Minimum maximum allowed step sizes adaptive integration (default: 1e-6 0.1). error_tol Tolerance used adaptive step size control (default: 0.01). Smaller values give accurate results cost runtime. method Used project_onto_variety_lagrange(), project_onto_variety_gradient_descent(), project_onto_variety_newton(). Lagrange method, \"newton\", simple R implementation Newton's method solve nonlinear algebraic system generated Lagrangian; otherwise, character string pass stats::optim() minimize sum squares Lagrangian. gradient-descent Newton methods, method controls line-search/fixed-step update: \"line\" (line search), \"optimal\", \"fixed\". maxit Number maximum iterations solving Newton's method. tol_x tolerance subsequent step sizes. ... Additional arguments pass stats::optim() method \"newton\". ga Learning rate gradient descent. max_ga Maximum learning rate gradient descent line search.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection onto a Variety — project-onto-variety","text":"x0 vector, numeric vector length x0. x0 matrix/data frame, matrix/data frame projected points number rows.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection onto a Variety — project-onto-variety","text":"Griffin, Z. J. Hauenstein (2015). Real solutions systems polynomial equations parameter continuation. Advances Geometry 15(2), pp.173–187. Bates, D., J. Hauenstein, . Sommese, C. Wampler (2013). Numerically Solving Polynomial Systems Bertini. SIAM. pp.34–35.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Projection onto a Variety — project-onto-variety","text":"David Kahle","code":""},{"path":"https://sonish13.github.io/vnorm/reference/project-onto-variety.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection onto a Variety — project-onto-variety","text":"","code":"library(\"ggplot2\") library(\"mpoly\")  if (FALSE) { # \\dontrun{ ## basic usage x0 <- c(1, 1) p1 <- mp(\"x^2 + y^2 - 1\") x1_proj <- project_onto_variety(x0, p1) x1_proj  # Residual on the variety should be near zero as.function(p1)(x1_proj)  df1 <- data.frame(   x = x0[1], y = x0[2],   x_proj = x1_proj[1], y_proj = x1_proj[2] ) ggplot() +   geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2)) +   geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df1) +   coord_equal()  ## adaptive time stepping (default) versus fixed step size x2_adapt <- project_onto_variety(x0, p1) x2_fixed <- project_onto_variety(x0, p1, adaptive = FALSE, dt = 0.01) x2_strict <- project_onto_variety(x0, p1, error_tol = 0.001)  rbind(   adaptive = x2_adapt,   fixed = x2_fixed,   adaptive_strict = x2_strict )  # Optional: inspect adaptive step messages project_onto_variety(x0, p1, message = TRUE)  ## precomputing polynomial/gradient/Hessian functions varorder <- c(\"x\", \"y\") gfunc <- as.function(p1, varorder = varorder) dg <- stats::deriv(p1, var = varorder) dgfunc <- as.function(dg, varorder = varorder) ddg <- lapply(dg, stats::deriv, var = varorder) ddgfunc_list <- lapply(ddg, as.function, varorder = varorder, silent = TRUE) ddgfunc <- function(x) sapply(ddgfunc_list, function(f) f(x)) project_onto_variety(x0, p1, gfunc = gfunc, dgfunc = dgfunc, ddgfunc = ddgfunc)  ## projecting multiple points (matrix or data frame input) x2 <- rbind(c(1, 1), c(-1, 0.3), c(0.2, -1.3)) project_onto_variety(x2, p1) project_onto_variety(as.data.frame(x2), p1)  ## alternative projection methods project_onto_variety_lagrange(x0, p1) project_onto_variety_newton(x0, p1) project_onto_variety_gradient_descent(x0, p1, method = \"line\") project_onto_variety_gradient_descent(x0, p1, method = \"optimal\") project_onto_variety_gradient_descent(x0, p1, method = \"fixed\")  ## naive usages / method comparison on a small grid # (gradient descent methods minimize g(x)^2 directly) library(\"dplyr\") set.seed(1) grid <- expand.grid(x = seq(-1, 1, by = 0.5), y = seq(-1, 1, by = 0.5)) grid$x <- jitter(grid$x) grid$y <- jitter(grid$y)  proj_homotopy <- project_onto_variety(grid, p1) proj_gd_opt <- project_onto_variety_gradient_descent(grid, p1, method = \"optimal\") proj_newton <- project_onto_variety_newton(grid, p1)  names(proj_homotopy) <- c(\"x_proj\", \"y_proj\") names(proj_gd_opt) <- c(\"x_proj\", \"y_proj\") names(proj_newton) <- c(\"x_proj\", \"y_proj\")  df_cmp <- bind_rows(   bind_cols(grid, proj_homotopy) |> mutate(method = \"homotopy (adaptive default)\"),   bind_cols(grid, proj_gd_opt)   |> mutate(method = \"naive gd on g^2 (optimal)\"),   bind_cols(grid, proj_newton)   |> mutate(method = \"newton on g^2\") )  ggplot() +   geom_variety(poly = p1, xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2)) +   geom_segment(     aes(x, y, xend = x_proj, yend = y_proj),     data = df_cmp, inherit.aes = FALSE, alpha = 0.6   ) +   geom_point(aes(x, y), data = grid, inherit.aes = FALSE, size = 0.8) +   coord_equal() +   facet_wrap(~ method)  ## changing adaptive control parameters project_onto_variety(   x0, p1,   adaptive = TRUE,   dt = 0.05,   dt_min = 1e-5,   dt_max = 0.2,   error_tol = 0.005,   message = TRUE )  ## more complex curve p_complex <- mp(\"(x^2 + y^2)^2 - 2 * (x^2 - y^2)\") x_complex <- c(1, 1) x_complex_proj <- project_onto_variety(x_complex, p_complex) df_complex <- data.frame(   x = x_complex[1], y = x_complex[2],   x_proj = x_complex_proj[1], y_proj = x_complex_proj[2] ) ggplot() +   geom_variety(poly = p_complex, xlim = c(-2, 2), ylim = c(-2, 2)) +   geom_segment(aes(x, y, xend = x_proj, yend = y_proj), data = df_complex) +   coord_equal()  ## projecting a sample from rvnorm (batch usage) # cut down on draws for example runtime samps <- rvnorm(500, p1, sd = 0.05, output = \"tibble\") idx <- sample(seq_len(nrow(samps)), size = min(75, nrow(samps))) subsamps <- samps[idx, , drop = FALSE] proj_sub <- project_onto_variety(subsamps[, c(\"x\", \"y\")], p1) names(proj_sub) <- c(\"x_proj\", \"y_proj\") df_sub <- dplyr::bind_cols(subsamps, proj_sub)  ggplot(df_sub, aes(x, y)) +   geom_segment(aes(xend = x_proj, yend = y_proj), alpha = 0.4) +   geom_point(size = 0.8) +   geom_variety(poly = p1, xlim = c(-2, 2), ylim = c(-2, 2), inherit.aes = FALSE) +   coord_equal()  ## higher-dimensional example x3 <- c(1, 1, 1) p2 <- mp(\"x^2 + y^2 + z^2 - 1\") project_onto_variety(x3, p2) } # }"},{"path":"https://sonish13.github.io/vnorm/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. mpoly mp","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rejection_sampler.html","id":null,"dir":"Reference","previous_headings":"","what":"Rejection Sampler for the Variety Normal Distribution — rejection_sampler","title":"Rejection Sampler for the Variety Normal Distribution — rejection_sampler","text":"Perform rejection sampling generate draws variety normal distribution.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rejection_sampler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rejection Sampler for the Variety Normal Distribution — rejection_sampler","text":"","code":"rejection_sampler(   n,   poly,   sd = 0.01,   vars = sort(mpoly::vars(poly)),   w = 1.25,   output = \"simple\",   dist = c(\"norm\", \"unif\"),   homo = TRUE,   correct_p_coefficients = FALSE,   correct_dp_coefficients = FALSE,   message = FALSE )"},{"path":"https://sonish13.github.io/vnorm/reference/rejection_sampler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rejection Sampler for the Variety Normal Distribution — rejection_sampler","text":"n number accepted draws return. poly mpoly object mpolyList object. sd \"standard deviation\" component normal kernel. vars character vector indeterminates distribution. w Proposal box constraints. single number, box window (-w, w) applied variables. length 2, interval used variables. named list can used specify bounds variable. output Either \"simple\" \"tibble\" output format. dist Either \"norm\" (normal) \"unif\" (uniform). homo TRUE, sampling done homoskedastic variety normal distribution. correct_p_coefficients TRUE, normalize polynomial coefficients. correct_dp_coefficients TRUE, normalize derivative coefficients. message TRUE, print progress messages showing remaining samples.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rejection_sampler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rejection Sampler for the Variety Normal Distribution — rejection_sampler","text":"matrix tibble containing accepted samples.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rejection_sampler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rejection Sampler for the Variety Normal Distribution — rejection_sampler","text":"","code":"if (FALSE) { # \\dontrun{ library(\"mpoly\")  # Single polynomial (circle) p1 <- mp(\"x^2 + y^2 - 1\") set.seed(1) rejection_sampler(100, p1, sd = 0.05, w = 1.5)  # Uniform band proposal around the variety, returning a tibble rejection_sampler(   100, p1, sd = 0.05, w = c(-1.5, 1.5),   dist = \"unif\", output = \"tibble\" )  # Two-polynomial system (upper/lower acceptance geometry differs by `homo`) p2 <- mp(c(\"x^2 + y^2 - 1\", \"y\")) rejection_sampler(50, p2, sd = 0.05, w = 1.5, homo = TRUE) rejection_sampler(50, p2, sd = c(0.05, 0.05), w = 1.5, homo = FALSE) } # }"},{"path":"https://sonish13.github.io/vnorm/reference/remove_stan_files.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove Files Created by compile_stan_code() — remove_stan_files","title":"Remove Files Created by compile_stan_code() — remove_stan_files","text":"Delete Stan source executable files tracked internal compile cache created compile_stan_code().","code":""},{"path":"https://sonish13.github.io/vnorm/reference/remove_stan_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove Files Created by compile_stan_code() — remove_stan_files","text":"","code":"remove_stan_files(path = getwd())"},{"path":"https://sonish13.github.io/vnorm/reference/remove_stan_files.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove Files Created by compile_stan_code() — remove_stan_files","text":"path Directory used compile_stan_code(). Defaults current working directory.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rvnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"The Variety Normal Distribution — rvnorm","title":"The Variety Normal Distribution — rvnorm","text":"Unnormalized density evaluation random generation variety normal distribution mean defined poly scale sd. See Details caveats.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rvnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Variety Normal Distribution — rvnorm","text":"","code":"rvnorm(   n,   poly,   sd,   output = \"simple\",   Sigma = NULL,   rejection = FALSE,   chains = 4L,   warmup = max(500, floor(n/2)),   inc_warmup = FALSE,   thin = 1L,   verbose = FALSE,   cores = min(chains, getOption(\"mc.cores\", 1L)),   homo = TRUE,   w,   vars,   numerator,   denominator,   refresh = 0L,   code_only = FALSE,   pre_compiled = TRUE,   user_compiled = FALSE,   show_messages = FALSE,   ... )"},{"path":"https://sonish13.github.io/vnorm/reference/rvnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Variety Normal Distribution — rvnorm","text":"n Number draws desired chain warmup. poly mpoly object. sd Scale parameter normal kernel. Sigma supplied, sd replaced Sigma. output One \"simple\", \"tibble\", \"stanfit\". Sigma Full covariance matrix diagonal vector covariance terms. rejection TRUE, rejection sampling used. chains number chains run random number generation, see stan(). warmup Number warmup iterations stan(). inc_warmup TRUE, MCMC warmup steps included output. thin stan() thin parameter. verbose TRUE, print additional progress messages. cores number CPU cores distribute chains across, see stan(). homo TRUE, sampling homoskedastic variety normal distribution. w named list box constraints vectors passed Stan, see examples. single number, box window (-w, w) applied variables. vars Character vector polynomial indeterminates. numerator, denominator Character scalars containing printed numerator denominator forms. refresh refresh argument stan(), governs much information provided user sampling. code_only TRUE, formulate return Stan code. pre_compiled Whether use precompiled Stan models. Available polynomials three indeterminates three degrees. Defaults TRUE. user_compiled TRUE, use user-compiled Stan program produced compile_stan_code(). Defaults FALSE. show_messages TRUE, Stan sampler messages shown. ... Additional parameters passed stan().","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rvnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Variety Normal Distribution — rvnorm","text":"Either (1) matrix whose rows individual draws distribution, (2) tibble::tbl_df object draws along additional information, (3) object class stanfit.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rvnorm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Variety Normal Distribution — rvnorm","text":"variety interested connected, strategy work well box. , likely need multiple chains, sampling may become biased toward one components -sampling others. Question: relative likelihood component, equal unit length, different components? generalize varieties varying dimensions?","code":""},{"path":"https://sonish13.github.io/vnorm/reference/rvnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Variety Normal Distribution — rvnorm","text":"","code":"library(\"tidyverse\") options(\"mc.cores\" = parallel::detectCores() - 1)  if (FALSE) { # \\dontrun{ ## basic usage ########################################  # single polynomial p <- mp(\"x^2 + y^2 - 1\") samps <- rvnorm(1000, p, sd = .05) head(samps) str(samps) plot(samps, asp = 1)  # returning a data frame (samps <- rvnorm(5000, p, sd = .05, w = 2, output = \"tibble\"))  ggplot(samps, aes(x, y)) +   geom_point(size = .5) +   coord_equal()  ggplot(samps, aes(x, y)) +   geom_point(size = .5) +   geom_variety(poly = p) +   coord_equal()  ggplot(samps, aes(x, y)) +   geom_point(aes(color = factor(.chain)), size = .5) +   geom_variety(poly = p, linewidth = 1) +   coord_equal()  ggplot(samps, aes(x, y)) +   stat_density2d(     aes(fill = after_stat(density)),     geom = \"raster\", contour = FALSE    ) +   geom_variety(poly = p) +   coord_equal()  library(\"ggdensity\") ggplot(samps, aes(x, y)) +   geom_hdr(xlim = c(-2,2), ylim = c(-2,2)) +   geom_variety(poly = p) +   coord_equal()  # in three variables (samps <- rvnorm(20, mp(\"x^2 + y^2 + z^2 - 1\"), sd = .05, w = 2)) apply(samps, 1, function(v) sqrt(sum(v^2)))  # more than one polynomial, # vars > # eqns, underdetermined system p <- mp(c(\"x^2 + y^2 + z^2 - 1\", \"z\")) (samps <- rvnorm(500, p, sd = .1, output = \"tibble\")) ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()  ggplot(samps, aes(x, y, color = `g[1]`)) + geom_point() +   scale_color_gradient2(mid = \"gray80\") + coord_equal()  ggplot(samps, aes(x, y, color = `g[2]`)) + geom_point() +   scale_color_gradient2(mid = \"gray80\") + coord_equal()  ggplot(samps, aes(x, z, color = `g[1]`)) + geom_point() +   scale_color_gradient2(mid = \"gray80\") + coord_equal()  # more than one polynomial, # vars < # eqns, overdetermined system p <- mp(c(\"3 x\", \"3 y\", \"2 x + 2 y\", \"3 (x^2 + y)\", \"3 (x^2 - y)\")) (samps <- rvnorm(500, p, sd = .1, output = \"tibble\"))  samps |>   select(x, y, starts_with(\"g\")) |>   pivot_longer(     starts_with(\"g\"),     names_to = \"equation\",     values_to = \"value\"   ) |>   ggplot(aes(x, y, color = value)) + geom_point() +     scale_color_gradient2(mid = \"gray80\") + coord_equal() +     facet_wrap(~ equation)  ## using refresh to get more info ########################################  rvnorm(2000, p, sd = .1, \"tibble\", verbose = TRUE) rvnorm(2000, p, sd = .1, \"tibble\", refresh = 500) rvnorm(2000, p, sd = .1, \"tibble\", refresh = 0) # default rvnorm(2000, p, sd = .1, \"tibble\", refresh = -1)  ## many chains in parallel ########################################  options(mc.cores = parallel::detectCores()) p <- mp(\"x^2 + (4 y)^2 - 1\") (samps <- rvnorm(1e4, p, sd = .01, \"tibble\", verbose = TRUE, chains = 8)) ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .01*c(1,1)) + coord_equal() # decrease sd to get more uniform sampling  ## windowing for unbounded varieties ######################################## # windowing is needed for unbounded varieties # in the following, look at the parameters block  p <- mp(\"x y - 1\") # unbounded variety, 1 poly p <- mp(c(\"x y - 1\", \"y - x\")) # 2 polys  rvnorm(1e3, p, sd = .01, \"tibble\", code_only = TRUE) rvnorm(1e3, p, sd = .01, \"tibble\",  w = 1.15)  window <- list(\"x\" = c(-1.5, 1.5)) rvnorm(1e3, p, sd = .01, \"tibble\",  w = window)  ## the importance of normalizing ######################################## # one of the effects of the normalizing is to stabilize variances, making # them roughly equivalent globally over the variety.  # lemniscate of bernoulli p <- mp(\"(x^2 + y^2)^2 - 2 (x^2 - y^2)\")  # normalized, good (samps <- rvnorm(2000, p, .05, \"tibble\")) ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal() ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()  # unnormalized, bad (samps <- rvnorm(2000, p, .05, \"tibble\", homo = FALSE)) ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal() ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()  ## semi-algebraic sets ######################################## # inside the semialgebraic set x^2 + y^2 <= 1 # this is the same as x^2 + y^2 - 1 <= 0, so that # x^2 + y^2 - 1 + s^2 == 0 for some slack variable s # this is the projection of the sphere into the xy-plane.  p <- mp(\"1 - (x^2 + y^2) - s^2\") samps <- rvnorm(1e4, p, sd = .1, \"tibble\", chains = 8, refresh = 1e3) ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()  ggplot(sample_n(samps, 2e3), aes(x, y, color = s)) +   geom_point(size = .5) +   scale_color_gradient2() +   coord_equal()  # alternative representation # x^2 + y^2 - 1 <= 0 iff s^2 (x^2 + y^2 - 1) + 1 == 0 # note that it's gradient is more complicated. p <- mp(\"s^2 (x^2 + y^2 - 1) + 1\") samps <- rvnorm(1e4, p, sd = .1, \"tibble\", chains = 8, w = 2, refresh = 1e3) ggplot(samps, aes(x, y)) + geom_bin2d(binwidth = .05*c(1,1)) + coord_equal()  ## keeping the warmup / the importance of multiple chains ########################################  p <- mp(\"((x + 1.5)^2 + y^2 - 1) ((x - 1.5)^2 + y^2 - 1)\") ggplot() +   geom_variety(poly = p, xlim = c(-3,3)) +   theme(legend.position = \"top\") +   coord_equal()  # notice the migration of chains initialized away from the distribution # (it helps to make the graphic large on your screen) samps <- rvnorm(500, p, sd = .05, \"tibble\", chains = 8, inc_warmup = TRUE)  ## ideal-variety correspondence considerations ########################################  p <- mp(\"x^2 + y^2 - 1\")  samps_1 <- rvnorm(250, p^1, sd = .1, output = \"tibble\", chains = 8) samps_2 <- rvnorm(250, p^2, sd = .1, output = \"tibble\", chains = 8) samps_3 <- rvnorm(250, p^3, sd = .1, output = \"tibble\", chains = 8) samps_4 <- rvnorm(250, p^4, sd = .1, output = \"tibble\", chains = 8) samps <- bind_rows(mget(apropos(\"samps_[1-4]\"))) samps$power <- rep(seq_along(apropos(\"samps_[1-4]\")), each = 250)  ggplot(samps, aes(x, y, color = g < 0)) +   geom_point(size = .5) +   coord_equal(xlim = c(-3,3), ylim = c(-3,3)) +   facet_wrap(~ power)  ## neat examples ######################################## # an implicit Lissajous region, view in separate window large  # x = cos(m t + p) # y = sin(n t + q) (p <- lissajous(3, 2,  -pi/2, 0)) (p <- lissajous(4, 3,  -pi/2, 0)) (p <- lissajous(5, 4,  -pi/2, 0)) (p <- lissajous(3, 3,  0, 0)) (p <- lissajous(5, 5,  0, 0)) (p <- lissajous(7, 7,  0, 0)) ggplot() +   geom_variety(poly = p, xlim = c(-2, 2), ylim = c(-2, 2), n = 201,   show.legend = FALSE) +   coord_equal()  p <- plug(p, \"x\", mp(\".5 x\")) p <- plug(p, \"y\", mp(\".5 y\"))  # algebraic set samps <- rvnorm(5e3, p, sd = .01, \"tibble\", chains = 8, cores = 8) ggplot(samps, aes(x, y, color = factor(.chain))) +   geom_point(size = .5) +   coord_equal()  ggplot(samps, aes(x, y)) + geom_hdr() + coord_equal()  ggplot(samps, aes(x, y, color = factor(.chain))) +   geom_point(size = .5) +   coord_equal() +   facet_wrap(~ factor(.chain))  # semi-algebraic set samps_normd <- rvnorm(1e4, p + mp(\"s^2\"), sd = .01, \"tibble\", chains = 8,   cores = 8, homo = TRUE ) samps_unormd <- rvnorm(1e4, p + mp(\"s^2\"), sd = .01, \"tibble\", chains = 8,   cores = 8, homo = FALSE )  bind_rows(   samps_normd  |> mutate(normd = TRUE),   samps_unormd |> mutate(normd = FALSE) ) |>   ggplot(aes(x, y)) +     geom_point(size = .5) +     # geom_bin2d(binwidth = .05*c(1,1)) +     facet_grid(normd ~ .chain) +     coord_equal()  ggplot(samps_normd, aes(x, y)) +   geom_bin2d(binwidth = .05*c(1,1)) + coord_equal() } # }"},{"path":"https://sonish13.github.io/vnorm/reference/variety_solve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve a Zero-Dimensional Variety — variety_solve","title":"Solve a Zero-Dimensional Variety — variety_solve","text":"Estimates solution zero-dimensional variety sampling rvnorm() averaging draws. well-behaved varieties, method works reliably. multiple isolated components exist, sampler may favor others, posterior mean may fall true solutions.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/variety_solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve a Zero-Dimensional Variety — variety_solve","text":"","code":"variety_solve(   polylist,   sd = 0.01,   n = 1e+05,   sig_digit = 3,   vars = mpoly::vars(polylist),   inc_warmup = FALSE,   show_message = FALSE,   stanfit = FALSE,   ... )"},{"path":"https://sonish13.github.io/vnorm/reference/variety_solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve a Zero-Dimensional Variety — variety_solve","text":"polylist mpolyList mpoly object containing polynomials. sd Numeric scalar standard deviation used rvnorm() (default: 0.01). n Integer, number draws used averaging (default: 1e5). sig_digit Integer, significant digits used round solution (default: 3). vars Character vector variable names average; defaults mpoly::vars(polylist). inc_warmup Logical; include warmup draws extracting (default: FALSE). show_message Logical; show Stan sampling messages (default: FALSE). stanfit Logical; TRUE, return Stan fit solution (default: FALSE). ... Additional arguments passed rvnorm().","code":""},{"path":"https://sonish13.github.io/vnorm/reference/variety_solve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve a Zero-Dimensional Variety — variety_solve","text":"stanfit = FALSE, named numeric vector rounded posterior means. stanfit = TRUE, list stanfit (Stan fit) results (vector).","code":""},{"path":"https://sonish13.github.io/vnorm/reference/variety_solve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve a Zero-Dimensional Variety — variety_solve","text":"","code":"library(mpoly) if (FALSE) { # \\dontrun{ polylist <- mp(c(\"x^2 - y\", \"x^2 + y\"))  # Posterior-mean solution only variety_solve(polylist, n = 2e4, sd = 0.01, sig_digit = 3)  # Return Stan fit and solution variety_solve(polylist, n = 1e4, stanfit = TRUE)  } # }"},{"path":"https://sonish13.github.io/vnorm/reference/vnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"vnorm: Variety Normal Distribution — vnorm","title":"vnorm: Variety Normal Distribution — vnorm","text":"Samples, projects, visualizes variety normal distributions.","code":""},{"path":"https://sonish13.github.io/vnorm/reference/vnorm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"vnorm: Variety Normal Distribution — vnorm","text":"Maintainer: David Kahle david@kahle.io Authors: Sonish Lamsal sonish_lamsal1@baylor.edu","code":""}]
